<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
<title>ldk-core 0.1.1</title>
<link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>
<div id="container">
<div id="main">
<div id="navigation">
<br/>
<h1>ldk-core</h1>
<ul>
<li><a href="../index.html">Index</a></li>
</ul>
<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
<li><a href="#Function_Types">Function Types </a></li>
</ul>
<h2>Modules</h2>
<ul class="nowrap">
<li><a href="../modules/ldk.array.html">ldk.array</a></li>
<li><a href="../modules/ldk.debugx.html">ldk.debugx</a></li>
<li><a href="../modules/ldk.func.html">ldk.func</a></li>
<li><a href="../modules/ldk.predicates.html">ldk.predicates</a></li>
<li><strong>ldk.stringx</strong></li>
<li><a href="../modules/ldk.tablex.html">ldk.tablex</a></li>
</ul>
</div>
<div id="content">
<h1>Module<code>ldk.stringx</code></h1>
Extensions to the <code>string</code> module.
<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
<tr>
<td class="name" nowrap><a href="#F">F(s, values)</a></td>
<td class="summary">The formatted string interpolator; it inserts its arguments between corresponding parts of the pattern.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#S">S(s, values)</a></td>
<td class="summary">Simple string interpolator; it inserts its arguments between corresponding parts of a pattern.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#center">center(s, width[, pad=' '])</a></td>
<td class="summary">Centers a string on a specified width.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#chars">chars(s[, a])</a></td>
<td class="summary">Creates an array with the characters of a string.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#delete">delete(s, p[, plain])</a></td>
<td class="summary">Returns a copy of <code>s' with all characters in</code>x` deleted.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#each">each(s[, sep=' '[, max_count]], f)</a></td>
<td class="summary">Splits the string <code>s</code> into substring divided by the given separator <code>sep</code> and invoke <code>f</code> with each of them.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#each_line">each_line(s[, max_count], f)</a></td>
<td class="summary">Splits the string <code>s</code> into lines and invoke <code>f</code> with each of them.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#ends_with">ends_with(s, p[, plain])</a></td>
<td class="summary">Determines whether a string ends with a specified pattern.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#expand_tabs">expand_tabs(s[, tab_size=8])</a></td>
<td class="summary">Expands the tabs in a given string into spaces.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#find_last">find_last(s, p, init[, plain=`%s`])</a></td>
<td class="summary">Searches a string for the last occurrence of the specified pattern.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#format">format(s, ...)</a></td>
<td class="summary">Replaces a format specifiers in a given string with the string representation of a corresponding value; the function behaves like Lua's <code>string.format</code> but also support positional specifiers: <code>%n$...</code>.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#insert">insert(s, x[, position])</a></td>
<td class="summary">Inserts <code>x</code> before the character at the given <code>position</code> in <code>s</code>.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#justify_left">justify_left(s, width[, pad=' '])</a></td>
<td class="summary">Returns a left-justified string of the specified length by padding a given string with the specified padding characters.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#justify_right">justify_right(s, width[, pad])</a></td>
<td class="summary">Returns a right-justified string of the specified length by padding a given string with the specified padding characters.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#lines">lines(s[, max_count])</a></td>
<td class="summary">Returns an array containing the string <code>s</code> split into lines.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#partition">partition(s, sep[, plain])</a></td>
<td class="summary">Searches <code>sep</code> in the string <code>s</code> from the beginning of the string and returns the part before it, the match, and the part after it.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#partition_right">partition_right(s, sep[, plain])</a></td>
<td class="summary">Searches <code>sep</code> in the string <code>s</code> from the end of the string and returns the part before it, the match, and the part after it.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#split">split(s[, sep=`%s`[, empty[, max_count]]])</a></td>
<td class="summary">Splits a string into multiple strings based on a specified separator.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#squeeze">squeeze(s, p[, plain])</a></td>
<td class="summary">Returns the string <code>s</code> with all the runs of the characters in <code>x</code> replaced with a single character.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#starts_with">starts_with(s, p[, plain])</a></td>
<td class="summary">Determines whether a string begins with a specified pattern.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#tr">tr(s, from, to)</a></td>
<td class="summary">Shorthand for <code>translate</code>.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#translate">translate(s, from, to)</a></td>
<td class="summary">Returns a new string with characters in <code>from</code> replaced with the corresponding characters in <code>to</code>.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#trim">trim(s[, p=`%s`])</a></td>
<td class="summary">Removes all the leading and trailing occurrences of a specified pattern from a string.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#trim_left">trim_left(s[, p=`%s`])</a></td>
<td class="summary">Removes all the leading occurrences of a specified pattern from a string.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#trim_right">trim_right(s[, p=`%s`])</a></td>
<td class="summary">Removes all the trailing occurrences of a specified pattern from a string.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#wrap">wrap(s, width)</a></td>
<td class="summary">Wraps a given string to the specified width.</td>
</tr>
</table>
<h2><a href="#Function_Types">Function Types </a></h2>
<table class="function_list">
<tr>
<td class="name" nowrap><a href="#consumer">consumer(s)</a></td>
<td class="summary">signature of a <a href="../modules/ldk.stringx.html#each">each</a> or <a href="../modules/ldk.stringx.html#each_line">each_line</a> callback function</td>
</tr>
</table>
<!--<br/>
<br/> -->
<h2 class="section-header "><a name="Functions"></a>Functions</h2>
<dl class="function">
<dt>
<a name = "F"></a>
<strong>F(s, values)</strong>
</dt>
<dd>
<p>The formatted string interpolator; it inserts its arguments between corresponding parts of the pattern.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
a pattern to interpolate.
</li>
<li><span class="parameter">values</span>
<span class="types"><span class="type">table</span></span>
the arguments to be replaced.
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">string</span></span>
the formatted string.
</ol>
<h3>Usage:</h3>
<ul>
<pre class="example"><span class="global">print</span>(F(<span class="string">"$height%2.2f"</span>, {height = <span class="number">1.9</span>}))</pre>
</ul>
</dd>
<dt>
<a name = "S"></a>
<strong>S(s, values)</strong>
</dt>
<dd>
<p>Simple string interpolator; it inserts its arguments between corresponding parts of a pattern.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
a pattern to interpolate.
</li>
<li><span class="parameter">values</span>
<span class="types"><span class="type">table</span></span>
the arguments to be replaced.
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">string</span></span>
the formatted string.
</ol>
<h3>Usage:</h3>
<ul>
<pre class="example"><span class="global">print</span>(S(<span class="string">"Hello, $name"</span>, {name = <span class="string">'James'</span>})))</pre>
</ul>
</dd>
<dt>
<a name = "center"></a>
<strong>center(s, width[, pad=' '])</strong>
</dt>
<dd>
<p>Centers a string on a specified width.  If the specified width is greater than the input string's length, returns a new string padded with the specified character; otherwise it returns the input string unchanged.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string to be centered.
</li>
<li><span class="parameter">width</span>
<span class="types"><span class="type">integer</span></span>
the width of the line to center the line on.
</li>
<li><span class="parameter">pad</span>
<span class="types"><span class="type">string</span></span>
the character to use for padding.
(<em>default</em> ' ')
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">string</span></span>
the input string centered on a line of the specified width.
</ol>
</dd>
<dt>
<a name = "chars"></a>
<strong>chars(s[, a])</strong>
</dt>
<dd>
<p>Creates an array with the characters of a string.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
a string to be divided into characters.
</li>
<li><span class="parameter">a</span>
<span class="types"><span class="type">table</span></span>
a table where to store the characters.
(<em>optional</em>)
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">{string}</span></span>
an table with the characters of <code>s</code>.
</ol>
</dd>
<dt>
<a name = "delete"></a>
<strong>delete(s, p[, plain])</strong>
</dt>
<dd>
<p>Returns a copy of <code>s' with all characters in</code>x` deleted.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string.
</li>
<li><span class="parameter">p</span>
<span class="types"><span class="type">string</span></span>
the pattern representing the characters to delete.
</li>
<li><span class="parameter">plain</span>
<span class="types"><span class="type">boolean</span></span>
if <code>true</code> the pattern is considered a plain string.
(<em>optional</em>)
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">string</span></span>
the new string with the characters deleted.
</ol>
</dd>
<dt>
<a name = "each"></a>
<strong>each(s[, sep=' '[, max_count]], f)</strong>
</dt>
<dd>
<p>Splits the string <code>s</code> into substring divided by the given separator <code>sep</code> and invoke <code>f</code> with each of them.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string.
</li>
<li><span class="parameter">sep</span>
<span class="types"><span class="type">string</span></span>
the separator.
(<em>default</em> ' ')
</li>
<li><span class="parameter">max_count</span>
<span class="types"><span class="type">integer</span></span>
the maximum number of strings to process.
(<em>optional</em>)
</li>
<li><span class="parameter">f</span>
<span class="types"><a class="type" href="../modules/ldk.stringx.html#consumer">consumer</a></span>
the function to invoke.
</li>
</ul>
</dd>
<dt>
<a name = "each_line"></a>
<strong>each_line(s[, max_count], f)</strong>
</dt>
<dd>
<p>Splits the string <code>s</code> into lines and invoke <code>f</code> with each of them.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string.
</li>
<li><span class="parameter">max_count</span>
<span class="types"><span class="type">integer</span></span>
the maximum number of lines to process.
(<em>optional</em>)
</li>
<li><span class="parameter">f</span>
<span class="types"><a class="type" href="../modules/ldk.stringx.html#consumer">consumer</a></span>
the function to invoke.
</li>
</ul>
</dd>
<dt>
<a name = "ends_with"></a>
<strong>ends_with(s, p[, plain])</strong>
</dt>
<dd>
<p>Determines whether a string ends with a specified pattern.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string to be tested.
</li>
<li><span class="parameter">p</span>
<span class="types"><span class="type">string</span></span>
the pattern to search for; the pattern must not contain neither captures nor anchors.
</li>
<li><span class="parameter">plain</span>
<span class="types"><span class="type">boolean</span></span>
if <code>true</code> the pattern is considered a plain string.
(<em>optional</em>)
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">boolean</span></span>
<code>true</code> if the pattern is found at the end of the input string.
</ol>
</dd>
<dt>
<a name = "expand_tabs"></a>
<strong>expand_tabs(s[, tab_size=8])</strong>
</dt>
<dd>
<p>Expands the tabs in a given string into spaces.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string whose tabs will be expanded.
</li>
<li><span class="parameter">tab_size</span>
<span class="types"><span class="type">integer</span></span>
the size in spaces of each tab.
(<em>default</em> 8)
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">string</span></span>
the input string with the tabs replaces by the specified number of spaces.
</ol>
</dd>
<dt>
<a name = "find_last"></a>
<strong>find_last(s, p, init[, plain=`%s`])</strong>
</dt>
<dd>
<p>Searches a string for the last occurrence of the specified pattern.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string to be searched.
</li>
<li><span class="parameter">p</span>
<span class="types"><span class="type">string</span></span>
the pattern to search for.
</li>
<li><span class="parameter">init</span>
<span class="types"><span class="type">integer</span></span>
the index  where to start the search.
</li>
<li><span class="parameter">plain</span>
<span class="types"><span class="type">boolean</span></span>
if <code>true</code> the pattern is considered a plain string.
(<em>default</em> `%s`)
</li>
</ul>
<h3>Returns:</h3>
<ol>
<li>
<span class="types"><span class="type">integer</span></span>
the index where the pattern starts.</li>
<li>
<span class="types"><span class="type">integer</span></span>
the index where the pattern ends.</li>
<li>
... the captures of the pattern, if it contained any.</li>
</ol>
</dd>
<dt>
<a name = "format"></a>
<strong>format(s, ...)</strong>
</dt>
<dd>
<p>Replaces a format specifiers in a given string with the string representation of a corresponding value; the function behaves like Lua's <code>string.format</code> but also support positional specifiers: <code>%n$...</code>.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
a format string.
</li>
<li><span class="parameter">...</span>
the values to be formatted.
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">string</span></span>
a copy of <code>s</code> in which the format items have been replaced by the string representation of the corresponding value.
</ol>
<h3>Raises:</h3>
</dd>
<dt>
<a name = "insert"></a>
<strong>insert(s, x[, position])</strong>
</dt>
<dd>
<p>Inserts <code>x</code> before the character at the given <code>position</code> in <code>s</code>.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string.
</li>
<li><span class="parameter">x</span>
<span class="types"><span class="type">string</span></span>
the string to insert
</li>
<li><span class="parameter">position</span>
<span class="types"><span class="type">integer</span></span>
the position to insert the string at; it must be a valid index.
(<em>optional</em>)
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">string</span></span>
the new string; or <code>s</code> if the index is not valid.
</ol>
</dd>
<dt>
<a name = "justify_left"></a>
<strong>justify_left(s, width[, pad=' '])</strong>
</dt>
<dd>
<p>Returns a left-justified string of the specified length by padding a given string with the specified padding characters.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string to be left-justified.
</li>
<li><span class="parameter">width</span>
<span class="types"><span class="type">integer</span></span>
the width of the line to left-justify the line on.
</li>
<li><span class="parameter">pad</span>
<span class="types"><span class="type">string</span></span>
the character to use for padding.
(<em>default</em> ' ')
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">string</span></span>
the input string left-justified on a line of the specified width.
</ol>
</dd>
<dt>
<a name = "justify_right"></a>
<strong>justify_right(s, width[, pad])</strong>
</dt>
<dd>
<p>Returns a right-justified string of the specified length by padding a given string with the specified padding characters.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string to be right-justified.
</li>
<li><span class="parameter">width</span>
<span class="types"><span class="type">integer</span></span>
the width of the line to right-justify the line on.
</li>
<li><span class="parameter">pad</span>
<span class="types"><span class="type">string</span></span>
the character to use for padding.
(<em>optional</em>)
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">string</span></span>
the input string right-justified on a line of the specified width.
</ol>
</dd>
<dt>
<a name = "lines"></a>
<strong>lines(s[, max_count])</strong>
</dt>
<dd>
<p>Returns an array containing the string <code>s</code> split into lines.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string.
</li>
<li><span class="parameter">max_count</span>
<span class="types"><span class="type">integer</span></span>
the maximum number of lines to return.
(<em>optional</em>)
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">{string}</span></span>
an array whose elements contains the lines of <code>s</code>.
</ol>
</dd>
<dt>
<a name = "partition"></a>
<strong>partition(s, sep[, plain])</strong>
</dt>
<dd>
<p>Searches <code>sep</code> in the string <code>s</code> from the beginning of the string and returns the part before it, the match, and the part after it.  If it is not found, returns two empty strings and <code>s</code>.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string to be searched.
</li>
<li><span class="parameter">sep</span>
<span class="types"><span class="type">string</span></span>
the pattern to search
</li>
<li><span class="parameter">plain</span>
<span class="types"><span class="type">boolean</span></span>
if <code>true</code> the pattern is considered a plain string.
(<em>optional</em>)
</li>
</ul>
<h3>Returns:</h3>
<ol>
<li>
<span class="types"><span class="type">string</span></span>
the substring occurring before the specified pattern.</li>
<li>
<span class="types"><span class="type">string</span></span>
the substring matching the specified pattern.</li>
<li>
<span class="types"><span class="type">string</span></span>
the substring occurring after the specified pattern.</li>
</ol>
</dd>
<dt>
<a name = "partition_right"></a>
<strong>partition_right(s, sep[, plain])</strong>
</dt>
<dd>
<p>Searches <code>sep</code> in the string <code>s</code> from the end of the string and returns the part before it, the match, and the part after it.  If it is not found, returns two empty strings and <code>s</code>.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string.
</li>
<li><span class="parameter">sep</span>
<span class="types"><span class="type">string</span></span>
the separator.
</li>
<li><span class="parameter">plain</span>
<span class="types"><span class="type">boolean</span></span>
if <code>true</code> the pattern is considered a plain string.
(<em>optional</em>)
</li>
</ul>
<h3>Returns:</h3>
<ol>
<li>
<span class="types"><span class="type">string</span></span>
the part before the separator.</li>
<li>
<span class="types"><span class="type">string</span></span>
the separator</li>
<li>
<span class="types"><span class="type">string</span></span>
the part after the separator.</li>
</ol>
</dd>
<dt>
<a name = "split"></a>
<strong>split(s[, sep=`%s`[, empty[, max_count]]])</strong>
</dt>
<dd>
<p>Splits a string into multiple strings based on a specified separator.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string to be split.
</li>
<li><span class="parameter">sep</span>
<span class="types"><span class="type">string</span></span>
the pattern to remove; the pattern must not contain captures, and be a single character, or a character class: <code>'c'</code>, <code>'%a'</code>, <code>'[^%a]'</code>; the function behavior is undefined for any other type of pattern.
(<em>default</em> `%s`)
</li>
<li><span class="parameter">empty</span>
<span class="types"><span class="type">boolean</span></span>
whether to include empty strings.
(<em>optional</em>)
</li>
<li><span class="parameter">max_count</span>
<span class="types"><span class="type">integer</span></span>
the maximum number of substrings to return.
(<em>optional</em>)
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">{string}</span></span>
an array containing the substrings in the input string that are delimited by one or more separators.
</ol>
</dd>
<dt>
<a name = "squeeze"></a>
<strong>squeeze(s, p[, plain])</strong>
</dt>
<dd>
<p>Returns the string <code>s</code> with all the runs of the characters in <code>x</code> replaced with a single character.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string.
</li>
<li><span class="parameter">p</span>
<span class="types"><span class="type">string</span></span>
the pattern representing the characters to squeeze.
</li>
<li><span class="parameter">plain</span>
<span class="types"><span class="type">boolean</span></span>
if <code>true</code> the pattern is considered a plain string.
(<em>optional</em>)
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">string</span></span>
the new string.
</ol>
</dd>
<dt>
<a name = "starts_with"></a>
<strong>starts_with(s, p[, plain])</strong>
</dt>
<dd>
<p>Determines whether a string begins with a specified pattern.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string to be tested.
</li>
<li><span class="parameter">p</span>
<span class="types"><span class="type">string</span></span>
the pattern to search for; the pattern must not contain neither captures nor anchors.
</li>
<li><span class="parameter">plain</span>
<span class="types"><span class="type">boolean</span></span>
if <code>true</code> the pattern is considered a plain string.
(<em>optional</em>)
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">boolean</span></span>
<code>true</code> if the pattern is found at the beginning of the input string.
</ol>
</dd>
<dt>
<a name = "tr"></a>
<strong>tr(s, from, to)</strong>
</dt>
<dd>
<p>Shorthand for <code>translate</code>.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string.
</li>
<li><span class="parameter">from</span>
<span class="types"><span class="type">string</span></span>
the characters to replace.
</li>
<li><span class="parameter">to</span>
<span class="types"><span class="type">string</span></span>
the replacement characters.
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">string</span></span>
the new string.
</ol>
<h3>See also:</h3>
<ul>
<a href="../modules/ldk.stringx.html#translate">translate</a>
</ul>
</dd>
<dt>
<a name = "translate"></a>
<strong>translate(s, from, to)</strong>
</dt>
<dd>
<p>Returns a new string with characters in <code>from</code> replaced with the corresponding characters in <code>to</code>.  Characters in <code>from</code> that do not have a correspondent character in <code>to</code> are removed.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string.
</li>
<li><span class="parameter">from</span>
<span class="types"><span class="type">string</span></span>
the characters to replace.
</li>
<li><span class="parameter">to</span>
<span class="types"><span class="type">string</span></span>
the replacement characters.
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">string</span></span>
the new string.
</ol>
</dd>
<dt>
<a name = "trim"></a>
<strong>trim(s[, p=`%s`])</strong>
</dt>
<dd>
<p>Removes all the leading and trailing occurrences of a specified pattern from a string.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string to be trimmed.
</li>
<li><span class="parameter">p</span>
<span class="types"><span class="type">string</span></span>
the pattern to remove; the pattern must not contain captures, and be a single character, or a character class: <code>'c'</code>, <code>'%a'</code>, <code>'[^%a]'</code>; the function behavior is undefined for any other type of pattern.
(<em>default</em> `%s`)
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">string</span></span>
the string that remains after all the leading and trailing occurrences of the specified pattern are removed from the input string.
</ol>
</dd>
<dt>
<a name = "trim_left"></a>
<strong>trim_left(s[, p=`%s`])</strong>
</dt>
<dd>
<p>Removes all the leading occurrences of a specified pattern from a string.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string to be trimmed.
</li>
<li><span class="parameter">p</span>
<span class="types"><span class="type">string</span></span>
the pattern to remove; the pattern must not contain captures, and be a single character, or a character class: <code>'c'</code>, <code>'%a'</code>, <code>'[^%a]'</code>; the function behavior is undefined for any other type of pattern.
(<em>default</em> `%s`)
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">string</span></span>
the string that remains after all the leading occurrences of the specified pattern are removed from the input string.
</ol>
</dd>
<dt>
<a name = "trim_right"></a>
<strong>trim_right(s[, p=`%s`])</strong>
</dt>
<dd>
<p>Removes all the trailing occurrences of a specified pattern from a string.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string to be trimmed.
</li>
<li><span class="parameter">p</span>
<span class="types"><span class="type">string</span></span>
the pattern to remove; the pattern must not contain captures, and be a single character, or a character class: <code>'c'</code>, <code>'%a'</code>, <code>'[^%a]'</code>; the function behavior is undefined for any other type of pattern.
(<em>default</em> `%s`)
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">string</span></span>
the string that remains after all the trailing occurrences of the specified pattern are removed from the input string.
</ol>
</dd>
<dt>
<a name = "wrap"></a>
<strong>wrap(s, width)</strong>
</dt>
<dd>
<p>Wraps a given string to the specified width.</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
the string to be wrapped.
</li>
<li><span class="parameter">width</span>
<span class="types"><span class="type">integer</span></span>
the width the line is wrapped to.
</li>
</ul>
<h3>Returns:</h3>
<ol>
<span class="types"><span class="type">string</span></span>
the input string wrapped to the specified width.
</ol>
</dd>
</dl>
<h2 class="section-header "><a name="Function_Types"></a>Function Types </h2>
<dl class="function">
<dt>
<a name = "consumer"></a>
<strong>consumer(s)</strong>
</dt>
<dd>
<p>signature of a <a href="../modules/ldk.stringx.html#each">each</a> or <a href="../modules/ldk.stringx.html#each_line">each_line</a> callback function</p>
<h3>Parameters:</h3>
<ul>
<li><span class="parameter">s</span>
<span class="types"><span class="type">string</span></span>
a string
</li>
</ul>
<h3>See also:</h3>
<ul>
<li><a href="../modules/ldk.stringx.html#each">each</a></li>
<li><a href="../modules/ldk.stringx.html#each_line">each_line</a></li>
</ul>
</dd>
</dl>
</div><!-- id="content" -->
</div><!-- id="main" -->
</div><!-- id="container" -->
</body>
</html>
